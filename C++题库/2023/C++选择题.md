# C++11面试选择题（2023版）

### 1. main函数执行之前主要完成了哪些工作（多选）?​
A. 设置栈指针​<br />
B. 初始化静态变量和全局变量​<br />
C. 为未初始化的全局变量赋初值​<br />
D. 调用全局对象的构造函数​<br />
​
答案:ABCD​
### 2. 在传递函数参数时,以下哪种情况应该使用引用（多选）?​
A. 需要修改实参​<br />
B. 实参是基本数据类型 ​<br />
C. 实参是数组​<br />
D. 实参是类对象​<br />
​
答案:AD​
### 3. 判断以下指针类型,哪个表示指向常量的指针（多选）?​
A. char * const p ​<br />
B. const char *p<br />
​C. char const *p​<br />
D. const char * const p​<br />
​
答案:BC​
### 4. 模板的好处是（多选）?​
A. 提高代码复用​<br />
B. 实现通用编程​<br />
C. 支持任意类型​<br />
D. 提高代码编译效率​<br />
​
答案:ABC​
​
### 5. 结构体内存对齐时,可以使用哪个关键字指定对齐方式?​
A. struct ​<br />
B. alignof​<br />
C. alignas​<br />
D. packed​<br />
​
答案:C​
​
### 6. 引用与指针的区别是?​
A. 引用可以为空​<br />
B. 引用只有一级,指针可以多级​<br />
C. 引用在初始化后可以改变，而指针不能​<br />
D. 对引用使用sizeof()得到的结果，比对指针使用sizeof()小​<br />
答案:B​
​
### 7. 下列哪个宏定义是正确的?
​A. #define MAX(a,b) (a>b?a:b)​<br />
B. #define MAX(a,b) {a>b?a:b;}<br /> ​
C. #define MAX(a,b) (a>b?a:b);​<br />
D. #define MAX(a,b) a>b?a:b​<br />
​
答案:A​
​
### 8. 使用new和delete与malloc和free相比,哪个更安全?​
A. new和delete​<br />
B. malloc和free​<br />
C. 二者相同​<br />
D. 情况因语言版本不同而异​<br />
​
答案:A ​
​
### 9. 下列哪种情况不会调用拷贝构造函数?​
A. 用一个对象初始化另一个对象​<br />
B. 函数的参数是类的对象 ​<br />
C. 函数返回值是类的对象​<br />
D. 引用返回函数体内对象​<br />
​
答案:D​
​
### 10. 在32位系统下,一个指针变量占用多少字节?​
A. 2​<br />
B. 4​<br />
C. 8​<br />
D. 16​<br />
​答案: B​
​
### 11. 下列哪个语句可以释放malloc分配的内存?​
A. delete p;​<br />
B. free(p); ​<br />
C. delete[] p;​<br />
D. free(p, sizeof(p));​<br />
​
答案:B​
​
### 12. 下列哪个关键字可以避免对象被复制?​
A. static​<br />
B. const ​<br />
C. volatile​<br />
D. mutable​<br />
​
答案:B​
​
### 13. 在类的声明中,public、protected和private的区别是?​
A. public可以在类内外访问,protected只能在类内访问,private只能在类内访问 <br />​
B. public可以在类内外访问,protected只能在派生类中访问,private只能在类内访问​<br />
C. public可以在类内外访问,protected可以在类内和派生类中访问,private只能在类内访问​<br />
D. 三者在类的内外都可以访问​<br />
​
答案:C​
​
### 14. 在类的声明中,哪个访问控制符可以让基类成员在派生类中保持原有访问权
限? ​
A. public<br />
​B. protected ​<br />
C. private​<br />
D. 都不能​<br />
​
答案:A​
​
### 15. 判断以下语句,哪个是错误的?​
A. int a[5] = {1, 2}; ​<br />
B. int *p = new int[5];​<br />
C. int *p = new int(5);​<br />
D. int *p = new int{5}; ​<br />
​
答案:C​
​
### 16. 在下面的代码中,调用func函数后,值传递的变量a是否会被修改?​
void func(int a) {​<br />
a = 10; ​<br />
}​<br />
int main() {​<br />
int a = 5;​<br />
func(a);​<br />
}​<br />
A. 会被修改​<br />
B. 不会被修改​<br />
C. 可能会也可能不会,取决于编译器优化​<br />
D. 结果不确定​<br />
​
答案:B​
### ​17. int a = 1, b = 5; a ^= b ^= a ^= b; 执行完后：​
A. a = 1; b = 5;​<br />
B. a = 4; b = 1;​<br />
C. a = 5; b = 1;​<br />
D. a =4 ; b = 5;​<br />
​
答案:C​
​
### 18. 在多线程环境下,使用哪个关键字修饰的变量可以在多个线程间共享?​
A. static​<br />
B. volatile​<br />
C. const​<br />
D. mutable​<br />
​
答案:B​
​
### 19. 下列哪个类不能被继承?​
A. class A {public: A(){} };​<br />
B. class B {private: B(){} }; ​<br />
C. class C {public: C(){} };​<br />
D. class D final {public: D(){}};​<br />
​
答案:D​
​
### 20. 在派生类的构造函数中,如果需要调用基类的构造函数,下列哪种调用方式是错
误的?​
A. Base::Base();​<br />
B. Base(); ​<br />
C. Base(参数列表);<br />​D. 使用初始化列表调用基类构造函数​<br />
​
答案:B​
​
### 21. 重载决议遵循以下哪条规则?​
A. 精确匹配优先​<br />
B. 类型转换优先​<br />
C. 默认参数优先 ​<br />
D. 不确定,由编译器决定​<br />
​
答案:A​
​
### 22. 在类的声明中,哪个关键字可以防止基类的虚函数被覆盖?​
A. virtual​<br />
B. override​<br />
C. overlaod​<br />
D. final​<br />
​
答案:D​
​
### 23. 下列哪种类型的数组可以作为函数的参数进行传递?​
A. 全局数组​<br />
B. 静态数组​<br />
C. 局部数组​<br />
D. 以上都可以​<br />
​
答案:D​
​
### 24. 对于非静态成员变量,下列哪种访问方式是正确的?
​A. 类名::变量名​<br />
B. 对象名.变量名 ​<br />
C. 对象名->变量名​<br />
D. ::变量名​<br />
​
答案:B​
​
### 25. 下列哪种函数可以访问类的私有成员?​
A. 友元函数​<br />
B. 静态成员函数​<br />
C. 析构函数 ​<br />
D. 构造函数​<br />
​
答案:A​
​
### 26. 在类的声明中,哪个关键字可以防止拷贝构造函数和拷贝赋值运算符函数被自
动生成?​
A. copy​<br />
B. nocopy​<br />
C. noinherit ​<br />
D. final​<br />
​
答案:D​
​
### 27. 下列哪种继承方式可以使基类的私有成员在派生类中保持私有权限?​
A. 公有继承​<br />
B. 保护继承 ​<br />
C. 私有继承​<br />
D. 都不能​<br />
​答案:C​
​
### 28. 使用虚析构函数的目的是?​
A. 防止内存泄漏​<br />
B. 实现运行时多态​<br />
C. 提高析构效率​<br />
D. 自动调用析构函数​<br />
​
答案:A​
​
### 29. 在类的声明中,mutable关键字的作用是?​
A. 允许成员变量在const函数中被修改​<br />
B. 允许类对象被复制 ​<br />
C. 定义可变模板​<br />
D. 声明可变引用​<br />
​
答案:A​
​
### 30. 在下面的代码中,调用func函数后,a的值是否会被修改?​
void func(int& a) {​
a = 10;​
}​
int main() {​
int a = 5; ​
func(a);​
}​
A. 会被修改<br />
B. 不会被修改 ​<br />
C. 可能会也可能不会,取决于编译器优化<br />
​D. 结果不确定​<br />
​
答案:A​
​
### 31. 使用引用返回局部变量通常会导致什么问题?​
A. 内存泄漏​<br />
B. 资源竞争​<br />
C. 缓冲区溢出 ​<br />
D. 野指针错误​<br />
​
答案:D​
​
### 32. 在多线程环境下,哪种锁允许多个线程同时读共享资源?
A. 互斥锁​<br />
B. 写锁​<br />
C. 读写锁​<br />
D. 条件锁​<br />
​
答案:C​
​
### 33. 下列哪个关键字可以避免编译器优化对代码的影响?​
A. restrict​<br />
B. volatile​<br />
C. atomic ​<br />
D. thread_local ​<br />
​
答案:B​
​
### ​34. 下列哪种函数不能被重载?​
A. 静态成员函数​<br />
B. 常成员函数 ​<br />
C. 内联成员函数​<br />
D. 友元函数​<br />
​
答案:B​
​
### 35. 在类的声明中,使用explicit关键字的作用是? ​
A. 防止隐式类型转换​<br />
B. 启用显式类型转换​<br />
C. 声明显式构造函数​<br />
D. 定义显式的类​<br />
​
答案:A​
​
### 36. 在下面的代码中,sizeof(str)的结果是?​
const char* str = "hello";​
A. 5​<br />
B. 未定义​<br />
C. 与指针大小相同​<br />
D. 取决于编译环境​<br />
​
答案:C​
​
### 37. 下列哪种内存分配方式允许自定义构造和析构?​
A. malloc和free​<br />
B. new和delete​<br />
C. calloc和free<br />
​D. realloc和free​<br />
​
答案:B​
​
### 38. 在下列选项中,哪个不是C++中构造函数的类型?​
A. 默认构造函数​<br />
B. 拷贝构造函数​<br />
C. 静态构造函数​<br />
D. 移动构造函数​<br />
​
答案:C​
​
### 39. 在类的声明中,声明构造函数为private的作用是?​
A. 防止类被实例化​<br />
B. 防止继承​<br />
C. 防止访问 ​<br />
D. 优化构造过程​<br />
​
答案:A​
​
### 40. 模板类通常定义在头文件中的原因是?​
A. 提高可用性和复用性​<br />
B. 方便调试​<br />
C. 加快编译速度​<br />
D. 减小代码量​<br />
​
答案: A​