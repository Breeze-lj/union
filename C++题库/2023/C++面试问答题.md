# C++11面试问答题（2023版）

## 1. 在main函数执行之前和之后执行的代码可能是什么？

**mian函数执行之前**，主要就是初始化系统相关资源：

*   设置栈指针

*   初始化静态变量`static`和全局变量`global`，即[.data段的内容](https://blog.csdn.net/weixin_57154303/article/details/128430141 "内存布局")

*   将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`false`，指针为`NULL`等，即`.bss`段的内容

*   全局对象初始化，在mian之前调用构造函数，这是可能会执行前的一些代码

*   将mian函数的参数argc，argv等传递给main函数，然后才真正运行mian函数

*   [\_\_attribute\_\_((constructor)](https://blog.csdn.net/stone8761/article/details/122498016 "__attribute__((constructor))用法")(修饰语句，放在函数之前，可以使其修饰的函数在main函数之前运行)

**main函数执行之后：**

*   全局对象的析构函数会在main函数之后执行；

*   可以用[atexit](https://wenku.baidu.com/view/6c22c973a11614791711cc7931b765ce05087a2c.html?_wkts_=1702088243659\&bdQuery=atexit%E5%87%BD%E6%95%B0 "atexit函数")注册一个函数，它会在main之后执行；

*   `__attribute__((destructor))`(修饰语句，放在函数之前，可以使其修饰的函数在main函数之后执行)

## 2. 结构体内存对齐问题？

*   结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。

*   未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）

C++11以后引入两个关键字**alignas**与**alignof**。其中**alignof**可以计算出类型的对齐方式，**alignas**可以指定结构体的 对齐方式。

但是alignas在某种情况下是不能使用的，具体见下面的例子：

```c++
// alignas生效的情况

struct Info {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl; // 6 2 + 2 + 2
std::cout << alignof(Info) << std::endl; // 2

struct alignas(4) Info2 {
  uint8_t a;
  uint16_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl; // 8 4 + 4
std::cout << alignof(Info2) << std::endl; // 4
```

`alignas`将内存对齐调整为4个字节。所以`sizeof(Info2)`的值变为了8。

```c++
// alignas 失效的情况

struct Info {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info) << std::endl; // 12 4 + 4 + 4
std::cout << alignof(Info) << std::endl; // 4

struct alignas(2) Info2 {
  uint8_t a;
  uint32_t b;
  uint8_t c;
};

std::cout << sizeof(Info2) << std::endl; // 12 4 + 4 + 4
std::cout << alignof(Info2) << std::endl; // 4
```

若`alignas`小于自然对齐的最小单位，则被忽略。

## 3. 指针和引用的区别

*   指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名

*   指针可以有多级，引用只有一级

*   指针可以为空，引用不能为空且在定义时必须初始化

*   指针在初始化后可以改变指向，而引用在初始化之后不可再改变

*   sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向的变量的大小

*   当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。

*   引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间

参考代码

```c++
void test(int *p) {
  int a=1;
  p=&a;
  cout<<p<<" "<<*p<<endl;
}

int main(void) {
  int *p=NULL;
  test(p);
  if(p==NULL)
    cout<<"指针p为NULL"<<endl;
  return 0;
}

//运⾏结果为：
//0x22ff44 1
//指针p为NULL
void testPTR(int* p) {
  int a = 12;
  p = &a;
}

void testREFF(int& p) {
  int a = 12;
  p = a;
}

void main() {
  int a = 10;
  int* b = &a;
  testPTR(b);//改变指针指向，但是没改变指针的所指的内容
  cout << a << endl;// 10
  cout << *b << endl;// 10
  a = 10;
  testREFF(a);
  cout << a << endl;//12
}

```

在编译器看来, int a \= 10; int \&b \= a; 等价于 int \* const b \= \&a; ⽽ b \= 20; 等价于 \*b \= 20; ⾃动转换为指针和⾃动解引⽤。

## 4. 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？

*   需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的。

*   对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小

*   类对象作为参数传递的时候使用引用，这是c++剋对象传递的标准方式

## 5. 堆和栈的区别

*   申请方式不同

    *   栈由系统自动分配

*   堆是自己申请和释放的

*   申请的大小限制不同

    *   栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改

    *   堆向高地址扩展，是不连续的内存区域，大小可以灵活调整

*   申请效率不同

    *   栈由系统分配，速度快，不会有碎片

    *   栈由程序员分配，速度慢，会有碎片

## 6. 你觉得堆快⼀点还是栈快⼀点？

毫无疑问是栈快⼀点。

因为操作系统会在底层对栈提供⽀持，会分配专⻔的寄存器存放栈的地址，栈的⼊栈出栈操作也十分简单，并且有专门的指令执⾏，所以栈的效率比较⾼也比较快。&#x20;

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要⼀定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第⼀次访问指针，第⼆次根据指针保存的地址访问内存，因此堆比较慢。

## 7. 区别以下指针类型？

```c++
int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
```

*   int \*p\[10]表示指针数组，强调数组概念，是⼀个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。

*   int (\*p)\[10]表⽰数组指针，强调是指针，只有⼀个变量，是指针类型，不过指向的是⼀个int类型的数组，这个数组大小是10。

*   int \*p(int)是函数声明，函数名是p，参数是int类型的，返回值是int \*类型的。

*   int (\*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

## 8. new / delete 与 malloc / free的异同

**相同点**

*   都可用于内存的动态申请和释放

**不同点**

*   前者是C++运算符，后者是C/C++语⾔标准库函数

*   new⾃动计算要分配的空间⼤⼩，malloc需要手工计算

*   new是类型安全的，malloc不是。例如：

```c++
int *p = new float[2]; //编译错误
int *p = (int*)malloc(2 * sizeof(double));//编译⽆错误
```

*   new调⽤名为**operator new**的标准库函数分配⾜够空间并调⽤相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调⽤名为**operator delete**的标准库函数释放该对象所用内存。后者均没有相关调用

*   后者需要库⽂件⽀持，前者不⽤

*   new是封装了malloc，直接free不会报错，但是这只是释放内存，⽽不会析构对象

## 9. malloc和new的区别？

*   malloc和free是标准库函数，⽀持覆盖；new和delete是运算符，不重载。

*   malloc仅仅分配内存空间，free仅仅回收空间，不具备调⽤构造函数和析构函数功能，⽤malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调⽤构造函数和析构函数。

*   malloc和free返回的是void类型指针（必须进⾏类型转换），new和delete返回的是具体类型指针。

## 10. 既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？

*   malloc/free和new/delete都是⽤来申请内存和回收内存的。

*   在对非基本数据类型的对象使⽤的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。⽽malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。

## 11. 被free回收的内存是立即返还给操作系统吗？

不是的，被free回收的内存会⾸先被ptmalloc使⽤双链表保存起来，当⽤户下⼀次申请内存的时候， 会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调⽤，占⽤过多的系统资源。同时ptmalloc也会尝试对小块内存进⾏合并，避免过多的内存碎⽚。

## 12. 宏定义和函数有何区别？

*   宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插⼊了代码，运⾏时不存在函数调 ⽤，执⾏起来更快；函数调⽤在运⾏时需要跳转到具体调⽤函数。

*   宏定义属于在结构中插⼊代码，没有返回值；函数调⽤具有返回值。

*   宏定义参数没有类型，不进⾏类型检查；函数参数具有类型，需要检查类型。

*   宏定义不要在最后加分号。

## 13. 宏定义和typedef区别？

*   宏主要⽤于定义常量及书写复杂的内容；typedef主要⽤于定义类型别名。

*   宏替换发⽣在编译阶段之前，属于⽂本插⼊替换；typedef是编译的⼀部分。

*   宏不检查类型；typedef会检查数据类型。

*   宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

*   注意对指针的操作，typedef char \* p\_char和#define p\_char char \*区别巨⼤。

## 14. 变量声明和定义区别？

*   声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。

*   相同变量可以在多处声明（外部变量extern），但只能在⼀处定义。

## 15. strlen和sizeof区别？

*   sizeof是运算符，并不是函数，结果在编译时得到⽽非运⾏中获得；strlen是字符处理的库函数。

*   sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

*   因为sizeof值在编译时确定，所以不能⽤来得到动态分配（运⾏时分配）存储空间的大小。

```c++
int main(int argc, char const *argv[]){
  const char* str = "name";
  sizeof(str); // 取的是指针str的⻓度，是8
  strlen(str); // 取的是这个字符串的⻓度，不包含结尾的 \0。⼤⼩是4
  return 0;
}
```

## 16. 常量指针和指针常量区别？

*   指针常量是⼀个指针，读成常量的指针，指向⼀个只读变量，也就是后⾯所指明的int const 和 const int，都是⼀个常量，可以写作int const \*p或const int \*p。

*   常量指针是⼀个不能给改变指向的指针。指针是个常量，必须初始化，⼀旦初始化完成，它的值 （也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int \*const p。

## 17. a和\&a有什么区别？

假设数组int a\[10]; int (\*p)\[10] \= \&a;其中：

*   a是数组名，是数组⾸元素地址，+1表示地址值加上⼀个int类型的大小，如果a的值是 0x00000001，加1操作后变为0x00000005。\*(a + 1) \= a\[1]。

*   \&a是数组的指针，其类型为int (\*)\[10]（就是前⾯提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后⼀个元素的地址。

*   若(int \*)p ，此时输出 \*p时，其值为a\[0]的值，因为被转为int \*类型，解引⽤时按照int类型大小来读取。

## 18. C++中struct和class的区别

**相同点**

*   两者都拥有成员函数、公有和私有部分

*   任何可以使⽤class完成的⼯作，同样可以使⽤struct完成

**不同点**

*   两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的

*   class默认是private继承，⽽struct模式是public继承

**引申**：C++和C的struct区别

*   C语⾔中：struct是⽤⼾⾃定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），⽀持成员函数的定义，（C++中的struct能继承，能实现多态）

*   C中struct是没有权限的设置的，且struct中只能是⼀些变量的集合体，可以封装数据却不可以隐藏数据，⽽且成员不可以是函数

*   C++中，struct增加了访问权限，且可以和类⼀样有成员函数，成员默认访问说明符为public（为了与C兼容）

*   struct作为类的⼀种特例是⽤来⾃定义数据结构的。⼀个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使⽤，此外结构体struct在C++中被当作类的⼀种特例

## 19. C++中const和static的作用

**static**

*   不考虑类的情况

    *   隐藏。所有不加static的全局变量和函数具有全局可⻅性，可以在其他⽂件中使⽤，加了之后只能在该⽂件所在的编译模块中使⽤

    *   默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区

    *   静态变量在函数内定义，始终存在，且只进⾏⼀次初始化，具有记忆性，其作⽤范围与局部变量相同，函数退出后仍然存在，但不能使⽤

*   考虑类的情况

    *   static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。

    *   static成员函数：不具有this指针，⽆法访问类对象的⾮static成员变量和⾮static成员函数；不能被声明为const、虚函数和volatile；可以被非static成员函数任意访问

**const**

*   不考虑类的情况

    *   const常量在定义时必须初始化，之后⽆法更改

    *   const形参可以接收const和⾮const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //...}

*   考虑类的情况

    *   const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进⾏初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化

    *   const成员函数：const对象不可以调⽤非const成员函数；⾮const对象都可以调⽤；不可以改变非mutable（⽤该关键字声明的变量可以在const成员函数中被修改）数据的值

## 20. final和override关键字

**override**

当在⽗类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进⾏重写，以下⽅法都可以：

```c++
class A
{
  virtual void foo();
}
class B : public A
{
  void foo(); //OK
  virtual void foo(); // OK
  void foo() override; //OK
}
```

如果不使⽤override，当你⼿⼀抖，将\*\*foo()写成了f00()\*\*会怎么样呢？结果是编译器并不会报错， 因为它并不知道你的⽬的是重写虚函数，⽽是把它当成了新的函数。如果这个虚函数很重要的话，那 就会对整个程序不利。所以，override的作⽤就出来了，它指定了⼦类的这个虚函数是重写的⽗类的，如果你名字不⼩⼼打错了的话，编译器是不会编译通过的：

```c++
class A
{
  virtual void foo();
};
class B : public A
{
  virtual void f00(); //OK，这个函数是B新增的，不是继承的
  virtual void f0o() override; //Error, 加了override之后，这个函数⼀定是继承⾃A的，
};

```

**final**

当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加 final关键字后被继承或重写，编译器会报错。例⼦如下：

```c++
class Base
{
  virtual void foo();
};

class A : public Base
{
  void foo() final; // foo 被override并且是最后⼀个override，在其⼦类中不可以重写
};

class B final : A // 指明B是不可以被继承的
{
  void foo() override; // Error: 在A中已经被final了
};

class C : B // Error: B is final
{
};

```

## 21. 拷贝初始化和直接初始化

*   当⽤于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调⽤与实参匹配的构造函数，拷贝初始化总是调⽤拷贝构造函数。拷贝初始化⾸先使⽤指定构造函数创建⼀个临时对 象，然后⽤拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下

```c++
string str1("I am a string");//语句1 直接初始化
string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调⽤拷⻉构造函数对str2进
string str3 = "I am a string";//语句3 拷⻉初始化，先为字符串”I am a string“创建临时对
string str4 = str1;//语句4 拷⻉初始化，这⾥相当于隐式调⽤拷⻉构造函数，⽽不是调⽤赋值运算
```

*   为了提⾼效率，允许编译器跳过创建临时对象这⼀步，直接调⽤构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价），但是需要辨别两种情况。

    *   当拷⻉构造函数为private时：语句3和语句4在编译时会报错

    *   使⽤explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

## 22. extern"C"的用法

为了能够**正确的在C++代码中**调⽤C语⾔的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语⾔进⾏编译，而不是C++；

哪些情况下使⽤extern "C"：&#x20;

（1）C++代码中调⽤C语⾔代码；&#x20;

（2）在C++中的头⽂件中使⽤；&#x20;

（3）在多个⼈协同开发时，可能有⼈擅⻓C语⾔，⽽有⼈擅⻓C++；&#x20;

举个例⼦，C++中调⽤C代码：

```c++
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__
extern "C"{
  typedef unsigned int result_t;
  typedef void* my_handle_t;
  my_handle_t create_handle(const char* name);
  result_t operate_on_handle(my_handle_t handle);
  void close_handle(my_handle_t handle);
}
```

综上，总结出使⽤⽅法，在C语⾔的头⽂件中，对其外部函数只能指定为extern类型，C语⾔中不⽀持extern "C"声明，在.c⽂件中包含了extern "C"时会出现编译语法错误。所以使⽤extern "C"全部 都放在于cpp程序相关⽂件或其头文件中。

总结出如下形式：

（1）C++调⽤C函数：

```c++
//xx.h
extern int add(...)
//xx.c
int add(){
}
//xx.cpp
extern "C" {
  #include "xx.h"
}
```

（2）C调⽤C++函数

```c++
//xx.h
extern "C"{
  int add();
}
//xx.cpp
int add(){
}
//xx.c
extern int add();
```

## 23. 野指针和悬空指针

都是是指向⽆效内存区域(这⾥的⽆效指的是"不安全不可控")的指针，访问⾏为将会导致未定义⾏为。

*   野指针&#x20;

野指针，指的是没有被初始化过的指针&#x20;

int main(void) { int\* p; // 未初始化 std::cout<< \*p << std::endl; // 未初始化就被使⽤ return 0; } 因此，为了防止出错，对于指针初始化时都是赋值为 nullptr ，这样在使⽤时编译器就会直接报错，产⽣非法内存访问。

*   悬空指针

悬空指针，指针最初指向的内存已经被释放了的⼀种指针。&#x20;

int main(void) { int \* p \= nullptr; int\* p2 \= new int; p \= p2; delete p2; }

此时 p和p2就是悬空指针，指向的内存已经被释放。继续使⽤这两个指针，⾏为不可预料。需要设置为 p\=p2\=nullptr 。此时再使⽤，编译器会直接保错。 避免野指针⽐较简单，但悬空指针⽐较麻烦。c++引⼊了智能指针，C++智能指针的本质就是避免悬空指针的产⽣。

**产生原因及解决办法**：

野指针：指针变量未及时初始化 \=> 定义指针变量及时初始化，要么置空。

悬空指针：指针free或delete之后没有及时置空 \=> 释放操作后⽴即置空。

## 24. C和C++的类型安全

**什么是类型安全？**

类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被⽤来形容编程语⾔，其根据在于该⻔编程语⾔是否提供保障类型安全的机制； 有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。

类型安全的编程语⾔与类型安全的程序之间，没有必然联系。好的程序员可以使⽤类型不那么安全的语⾔写出类型相当安全的程序，相反的，差⼀点⼉的程序员可能使⽤类型相当安全的语⾔写出类型不太安全的程序。绝对类型安全的编程语⾔暂时还没有。

**（1）C的类型安全**

C只在局部上下⽂中表现出类型安全，比如试图从⼀种结构体的指针转换成另⼀种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然⽽，C中相当多的操作是不安全的。以下是两个十分常见的例⼦：

*   printf格式输出

使⽤%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s 时，运⾏直接报segmentation fault错误

*   malloc函数的返回值

malloc是C中进⾏内存分配的函数，它的返回类型是void即空类型指针，常常有这样的⽤法char pStr\= (char\*)malloc(100\*sizeof(char))，这⾥明显做了显式的类型转换。

类型匹配尚且没有问题，但是⼀旦出现int\* pInt\=(int\*)malloc(100\*sizeof(char))就很可能带来⼀些问 题，⽽这样的转换C并不会提示错误。

**（2）C++的类型安全**

如果C++使⽤得当，它将远⽐C更有类型安全性。相⽐于C语⾔，C++提供了⼀些新的机制保障类型安全：

*   操作符new返回的指针类型严格与对象匹配，⽽不是void\*

*   C中很多以void\*为参数的函数可以改写为C++模板函数，⽽模板是⽀持类型检查的；

*   引⼊const关键字代替#define constants，它是有类型、有作⽤域的，⽽#define constants只是简 单的⽂本替换

*   ⼀些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下⽀持多种类型，当 然改写为模板也能保证类型安全

*   C++提供了dynamic\_cast关键字，使得转换过程更加安全，因为dynamic\_cast⽐static\_cast涉及 更多具体的类型检查。

例：不同类型指针之间转换

```c++
#include<iostream>
using namespace std;

class Parent{};
class Child1 : public Parent
{
public:
  int i;
  Child1(int e):i(e){}
};

class Child2 : public Parent
{
public:
  double d;
  Child2(double e):d(e){}
};
int main()
{
  Child1 c1(5);
  Child2 c2(4.1);
  Parent* pp;
  Child1* pc1;
  pp=&c1;
  pc1=(Child1*)pp; // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误
  cout<<pc1->i<<endl; //输出：5
  pp=&c2;
  pc1=(Child1*)pp; //强制转换，且类型发⽣变化，将造成错误
  cout<<pc1->i<<endl;// 输出：1717986918
  return 0;
}
```

例⼦是在两个类型指针之间进⾏强制转换。因此，想保证程序的类型安全性，应尽量避免使⽤空类型指针void\*，尽量不对两种类型指针做强制转换。

## 25. C++中的重载、重写（覆盖）和隐藏的区别

（1）重载（overload）&#x20;

重载是指在同⼀范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数 ⽬有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员 是否是虚函数⽆关。举个例子：

```c++
class A{
...
  virtual int fun();
  void fun(int);
  void fun(double, double);
  static int fun(char);
...
}

```

（2）重写（覆盖）（override）

重写指的是在派⽣类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数 且：

*   与基类的虚函数有相同的参数个数

*   与基类的虚函数有相同的参数类型

*   与基类的虚函数有相同的返回值类型

举个例子：

```c++
//⽗类
class A{
public:
  virtual int fun(int a){}
}
//⼦类
class B : public A{
public:
//重写,⼀般加override可以确保是重写⽗类的函数
  virtual int fun(int a) override{}
}

```

重载与重写的区别：

*   重写是⽗类和⼦类之间的垂直关系，重载是不同函数之间的⽔平关系

*   重写要求参数列表相同，重载则要求参数列表不同，返回值不要求

*   重写关系中，调⽤⽅法根据对象类型决定，重载根据调⽤时实参表与形参表的对应关系来选择函数体

（3）隐藏（hide）

隐藏指的是某些情况下，派⽣类中的函数屏蔽了基类中的同名函数，包括以下情况：

*   两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数**是否是虚函数**。举个例⼦：

```c++
//⽗类
class A{
public:
void fun(int a){
    cout << "A中的fun函数" << endl;
  }
};
//⼦类
class B : public A{
public:
//隐藏⽗类的fun函数
void fun(int a){
    cout << "B中的fun函数" << endl;
  }
};
int main(){
  B b;
  b.fun(2); //调⽤的是B中的fun函数
  b.A::fun(2); //调⽤A中fun函数
  return 0;
}
```

*   **两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：**

```c++
//⽗类
class A{
public:
  virtual void fun(int a){
    cout << "A中的fun函数" << endl;
  }
};
//⼦类
class B : public A{
public:
//隐藏⽗类的fun函数
  virtual void fun(char* a){
    cout << "A中的fun函数" << endl;
  }
};
int main(){
  B b;
  b.fun(2); //报错，调⽤的是B中的fun函数，参数类型不对
  b.A::fun(2); //调⽤A中fun函数
  return 0;
}
```

## 26. C++有哪几种的构造函数

C++中的构造函数可以分为4类：

*   默认构造函数

*   初始化构造函数（有参数）

*   拷⻉构造函数

*   移动构造函数（move和右值引⽤）

*   委托构造函数

*   转换构造函数

```c++
#include <iostream>
using namespace std;
class Student{
public:
  Student(){//默认构造函数，没有参数
    this->age = 20;
    this->num = 1000;
  };
  Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表
  Student(const Student& s){//拷⻉构造函数，这⾥与编译器⽣成的⼀致
    this->age = s.age;
    this->num = s.num;
  };
  Student(int r){ //转换构造函数,形参是其他类型变量，且只有⼀个形参
    this->age = r;
    this->num = 1002;
  };
  ~Student(){}
public:
  int age;
  int num;
};
int main(){
  Student s1;
  Student s2(18,1001);
  int a = 10;
  Student s3(a);
  Student s4(s3);
  printf("s1 age:%d, num:%d\n", s1.age, s1.num);
  printf("s2 age:%d, num:%d\n", s2.age, s2.num);
  printf("s3 age:%d, num:%d\n", s3.age, s3.num);
  printf("s2 age:%d, num:%d\n", s4.age, s4.num);
  return 0;
}
//运⾏结果
//s1 age:20, num:1000
//s2 age:18, num:1001
//s3 age:10, num:1002
//s2 age:10, num:1002

```

*   默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化⼯作

*   拷贝构造函数⽤于复制本类的对象

*   转换构造函数⽤于将其他类型的变量，隐式转换为本类对象

## 27. 浅拷贝和深拷贝的区别

**浅拷贝**

浅拷贝只是拷贝⼀个指针，并没有新开辟⼀个地址，拷贝的指针和原来的指针指向同⼀块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

**深拷贝**

深拷贝不仅拷贝值，还开辟出⼀块新的空间⽤来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在⾃⼰实现拷贝赋值的时候，如果有指针变量的话是需要⾃⼰实现深拷贝的。

## 28. 内联函数和宏定义的区别

*   在使⽤时，宏只做简单字符串替换（编译前）。⽽内联函数可以进⾏参数类型检查（编译时），且 具有返回值。

*   内联函数在编译时直接将函数代码嵌⼊到⽬标代码中，省去函数调⽤的开销来提⾼执⾏效率，并且 进⾏参数类型检查，具有返回值，可以实现重载。

*   宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产⽣歧义

*   内联函数有类型检测、语法判断等功能，⽽宏没有

**内联函数适用场景:**

*   使⽤宏定义的地⽅都可以使⽤ inline 函数。

*   作为类成员接⼝函数来读写类的私有成员或者保护成员，会提⾼效率。

## 29. volatile、mutable和explicit关键字的用法

(1) **volatile**

volatile 关键字是⼀种类型修饰符，⽤它声明的类型变量表⽰可以被某些编译器未知的因素更改，⽐如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进⾏优化，从⽽可以提供对特殊地址的稳定访问。

当要求使⽤ volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前⾯的指令刚刚从该处读取过数据。

**volatile定义变量的值是易变的，每次⽤到这个变量的值的时候都要去重新读取这个变量的值，⽽不是 读寄存器内的备份。多线程中被⼏个任务共享的变量需要定义为volatile类型。**

**volatile 指针**

volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念修饰由指针指向的对象、数据是 const 或 volatile 的：

```c++
const char* cpch;volatile char* vpch;
```

指针⾃⾝的值⸺⼀个代表地址的整数变量，是 const 或 volatile 的：

```c++
char* const pchc;char* volatile pchv;
```

注意：

*   可以把⼀个非volatile int赋给volatile int，但是不能把⾮volatile对象赋给⼀个volatile对象。

*   除了基本类型外，对⽤⼾定义类型也可以⽤volatile类型进⾏修饰。

*   C++中⼀个有volatile标识符的类只能访问它接⼝的⼦集，⼀个由类的实现者控制的⼦集。用户只能用const\_cast来获得对类型接⼝的完全访问。此外，volatile向const⼀样会从类传递到它的成员。

**多线程下的volatile**

有些变量是⽤volatile关键字声明的。当两个线程都要⽤到某⼀个变量且该变量的值会被改变时，应该 ⽤volatile声明，该关键字的作⽤是防⽌优化编译器把变量从内存装⼊CPU寄存器中。如果变量被 装⼊寄存器，那么两个线程有可能⼀个使⽤内存中的变量，⼀个使⽤寄存器中的变量，这会造成程序 的错误执⾏。volatile的意思是让编译器每次操作该变量时⼀定要从内存中真正取出，⽽不是使⽤已经 存在寄存器中的值。

（2）**mutable**

mutable的中⽂意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中， mutable也是为了突破const的限制⽽设置的。被mutable修饰的变量，将永远处于可变的状态，即使在⼀个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数⼀般会声明成const的。但是，有些时候，我们需要**在const函数⾥⾯修改⼀些跟类状态⽆关的数据成员，那么 这个函数就应该被mutable来修饰，并且放在函数后后⾯关键字位置。**

```c++
class person
{
  int m_A;
  mutable int m_B;//特殊变量 在常函数⾥值也可以被修改
public:
  void add() const//在函数⾥不可修改this指针指向的值 常量指针
  {
    m_A=10;//错误 不可修改值，this已经被修饰为常量指针
    m_B=20;//正确
  }
}
class person
{
  int m_A;
  mutable int m_B;//特殊变量 在常函数⾥值也可以被修改
}
int main()
{
  const person p;//修饰常对象 不可修改类成员的值
  p.m_A=10;//错误，被修饰了指针常量
  p.m_B=200;//正确，特殊变量，修饰了mutable
}
```

（3）**explicit**

explicit关键字⽤来修饰类的构造函数，被修饰的构造函数的类，不能发⽣相应的隐式类型转换，只能**以显示的⽅式进行类型转换**，注意以下⼏点：

*   explicit 关键字只能⽤于类内部的构造函数声明上

*   explicit 关键字作⽤于单个参数的构造函数

*   被explicit修饰的构造函数的类，不能发⽣相应的隐式类型转换

## 30. C++中有几种类型的new

在C++中，new有三种典型的使⽤⽅法：plain new，nothrow new和placement new

（1）**plain new**

⾔下之意就是普通的new，就是我们常⽤的new，在C++中定义如下：

```c++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此plain new在空间分配失败的情况下，抛出异常std::bad\_alloc⽽不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例⼦：

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
  try
  {
    char *p = new char[10e11];
    delete p;
  }
  catch (const std::bad_alloc &ex)
  {
    cout << ex.what() << endl;
  }
  return 0;
}
//执⾏结果：bad allocation

```

（2）**nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，⽽是返回NULL，定义如下：

```c++
void * operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

举个例⼦：

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
  char *p = new(nothrow) char[10e11];
  if (p == NULL)
  {
    cout << "alloc failed" << endl;
  }
  delete p;
  return 0;
}
//运⾏结果：alloc failed
```

（3）**placement new**

这种new允许在⼀块已经分配成功的内存上重新构造对象或对象数组。placement new不⽤担⼼内存分配失败，因为它根本不分配内存，它做的唯⼀⼀件事情就是调⽤对象的构造函数。定义如下：

```c++
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

使⽤placement new需要注意两点：

*   palcement new的主要⽤途就是反复使⽤⼀块较⼤的动态分配的内存来构造不同类型的对象或者他们的数组

*   placement new构造起来的对象数组，要显式的调⽤他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使⽤delete，这是因为placement new构造起来的对象或数组大小并不⼀定等于原来分配的内存大小，使⽤delete会造成内存泄漏或者之后释放内存时出现运⾏时错误。

举个例⼦：

```c++
#include <iostream>
#include <string>
using namespace std;
class ADT{
int i;
int j;
public:
  ADT(){
    i = 10;
    j = 100;
    cout << "ADT construct i=" << i << "j="<<j <<endl;
  }
  ~ADT(){
    cout << "ADT destruct" << endl;
  }
};
int main()
{
  char *p = new(nothrow) char[sizeof ADT + 1];
  if (p == NULL) {
    cout << "alloc failed" << endl;
  }
  ADT *q = new(p) ADT; //placement new:不必担⼼失败，只要p所指对象的的空间⾜够ADT创
  //delete q;//错误!不能在此处调⽤delete q;
  q->ADT::~ADT();//显⽰调⽤析构函数
  delete[] p;
  return 0;
}
//输出结果：
//ADT construct i=10j=100
//ADT destruct
```

## 31. static的用法和作用？

1.先来介绍它的第⼀条也是最重要的⼀条：隐藏。（static函数，static变量均可）

当同时编译多个⽂件时，所有未加static前缀的全局变量和函数都具有全局可⻅性。

2.static的第⼆个作⽤是保持变量内容的持久。（static变量中的记忆功能和全局⽣存期）存储在静态数据区的变量会在程序刚开始运⾏时就完成初始化，也是唯⼀的⼀次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量⽐起来，static可以控制变量的可⻅范围，说到底 static还是⽤来隐藏的。

3.static的第三个作⽤是默认初始化为0（static变量）

其实全局变量也具备这⼀属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这⼀特点可以减少程序员的⼯作量。

4.static的第四个作⽤：C++中的类成员声明static

1.  函数体内static变量的作⽤范围为该函数体，不同于auto变量，该变量的内存只被分配⼀次，因此其值在下次调⽤时仍维持上次的值；

2.  在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

3.  在模块内的static函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内；

4.  在类中的static成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉；

5.  在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因⽽只能访问类的static成员变量。

类内：

1.  static类对象必须要在类外进⾏初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

2.  由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问⾮static的类成员，只能访问 static修饰的类成员；

3.  static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每⼀个对象分配⼀个vptr指针，⽽vptr是通过this指针调⽤的，所以不能为virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function

## 32. 形参与实参的区别？

*   形参变量只有在被调⽤时才分配内存单元，在调⽤结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调⽤结束返回主调函数后则不能再使⽤该形参变量。

*   实参可以是常量、变量、表达式、函数等， ⽆论实参是何种类型的量，在进⾏函数调⽤时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先⽤赋值，输⼊等办法使实参获得确定值，会产⽣⼀个临时变量。

*   实参和形参在数量上，类型上，顺序上应严格⼀致， 否则会发⽣“类型不匹配”的错误。

*   函数调⽤中发⽣的数据传送是单向的。 即只能把实参的值传送给形参，⽽不能把形参的值反向地传送给实参。 因此在函数调⽤过程中，形参的值发⽣改变，⽽实参中的值不会变化。

*   当形参和实参不是指针类型时，在该函数运⾏时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制⼀份，在该函数运⾏结束的时候形参被释放，⽽实参内容不会改变。

## 33. 值传递、指针传递、引用传递的区别和效率

*   值传递：有⼀个形参向函数所属的栈拷⻉数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费⼀定的时间和空间。（传值）

*   指针传递：同样有⼀个形参向函数所属的栈拷⻉数据的过程，但拷⻉的数据是⼀个固定为4字节的地址。（传值，传递的是地址值）

*   引⽤传递：同样有上述的数据拷⻉过程，但其是针对地址的，相当于为该数据所在的地址起了⼀个别名。（传地址）

*   效率上讲，指针传递和引⽤传递⽐值传递效率⾼。⼀般主张使⽤引⽤传递，代码逻辑上更加紧凑、 清晰。

**引用传递和指针传递的不同**

*   对于引用参数的处理都会通过⼀个间接寻址的方式操作到主调函数中的相关变量。

*   而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。

*   从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引⽤对象的地址值（与实参名字不同，地址相同）。符号表⽣成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），⽽引⽤对象则不能修改。

## 34. 静态变量什么时候初始化

1.  初始化只有⼀次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。

2.  静态局部变量和全局变量⼀样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配 好了内存，但在C和C++中静态局部变量的初始化节点⼜有点不太⼀样。在C中，初始化发⽣在代码执⾏之前，编译阶段分配好内存之后，就会进⾏初始化，所以我们看到在C语⾔中⽆法使⽤变量对 静态局部变量进⾏初始化，在程序运⾏结束，变量所处的全局内存会被全部回收。

3.  ⽽在C++中，初始化时在执⾏相关代码时才会进⾏初始化，主要是由于C++引⼊对象后，要进⾏初始化必须执⾏相应构造函数和析构函数，在构造函数或析构函数中经常会需要进⾏某些程序中需要 进⾏的特定操作，并⾮简单地分配内存。所以C++标准定为全局或静态对象是有⾸次⽤到时才会进 ⾏构造，并通过atexit()来管理。在程序结束，按照构造顺序反⽅向进⾏逐个析构。所以在C++中是 可以使⽤变量对静态局部变量进⾏初始化的。

## 35. const关键字的作用有哪些?

1.  阻⽌⼀个变量被改变，可以使⽤const关键字。在定义该const变量时，通常需要对它进⾏初始化， 因为以后就没有机会再去改变它了；

2.  对指针来说，可以指定指针本⾝为const，也可以指定指针所指的数据为const，或⼆者同时指定为 const；

3.  在⼀个函数声明中，const可以修饰形参，表明它是⼀个输⼊参数，在函数内部不能改变其值；

4.  对于类的成员函数，若指定其为const类型，则表明其是⼀个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；

5.  对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

6.  const成员函数可以访问⾮const对象的⾮const数据成员、const数据成员，也可以访问const对象 内的所有数据成员；

7.  ⾮const成员函数可以访问⾮const对象的⾮const数据成员、const数据成员，但不可以访问const 对象的任意数据成员；

8.  ⼀个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，⽽且编译器不允 许它为⼀个const对象所调⽤。因此const对象只能调⽤const成员函数。

9.  const类型变量可以通过类型转换符const\_cast将const类型转换为⾮const类型；

10. const类型变量必须定义的时候进⾏初始化，因此也导致如果类的成员变量有const类型的变量， 那么该变量必须在类的初始化列表中进⾏初始化；

11. 对于函数值传递的情况，因为参数传递是通过复制实参创建⼀个临时变量传递进函数的，函数内 只能改变临时变量，但⽆法改变实参。则这个时候⽆论加不加const对实参不会产⽣任何影响。但 是在引⽤或指针传递函数调⽤中，因为传进去的是⼀个引⽤或指针，这样函数内部可以改变引⽤ 或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译 器对调⽤函数的选择是根据实参进⾏的，所以，只有引⽤传递和指针传递可以⽤是否加const来重 载。⼀个拥有顶层const的形参⽆法和另⼀个没有顶层const的形参区分开来。

## 36. delete p、delete\[]p、allocator都有什么作用？

1.  动态数组管理new⼀个数组时，\[]中必须是⼀个整数，但是不⼀定是常量整数，普通数组必须是⼀个常量整数；

2.  new动态数组返回的并不是数组类型，⽽是⼀个元素类型的指针；

3.  delete\[]时，数组中的元素按逆序的顺序进⾏销毁；

4.  new在内存分配上⾯有⼀些局限性，new的机制是将内存分配和对象构造组合在⼀起，同样的， delete也是将对象析构和内存释放组合在⼀起的。allocator将这两部分分开进⾏，allocator申请⼀部分内存，不进⾏初始化对象，只有当需要的时候才进⾏初始化操作。

## 37. new和delete的实现原理， delete是如何知道释放内存的大小的？

1.  new简单类型直接调⽤operator new分配内存；&#x20;

    *   ⽽对于复杂结构，先调⽤operator new分配内存，然后在分配的内存上调⽤构造函数；&#x20;

    *   对于简单类型，new\[]计算好⼤⼩后调⽤operator new；&#x20;

    *   对于复杂数据结构，new\[]先调⽤operator new\[]分配内存，然后在p的前四个字节写⼊数组⼤⼩n，然后调⽤n次构造函数，针对复杂类型，new\[]会额外存储数组⼤⼩；

    *   &#x20;① new表达式调⽤⼀个名为operator new(operator new\[])函数，分配⼀块⾜够⼤的、原始的、未命名的内存空间；&#x20;

    *   ② 编译器运⾏相应的构造函数以构造这些对象，并为其传⼊初始值；

    *   ③ 对象被分配了空间并构造完成，返回⼀个指向该对象的指针。

2.  delete简单数据类型默认只是调⽤free函数；复杂数据类型先调⽤析构函数再调⽤operator delete；针对简单类型，delete和delete\[]等同。假设指针p指向new\[]分配的内存。因为要4字节存储 数组⼤⼩，实际分配的内存地址为\[p-4]，系统记录的也是这个地址。delete\[]实际释放的就是p-4指向 的内存。⽽delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。

3.  需要在 new \[] ⼀个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的⼤⼩，专⻔保存数组的⼤⼩，在 delete \[] 时就可以取出这个保存的数，就知道了需要调⽤析构函数多少次了。

